# ==============================================================================
#
# Client (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# Generator info:
#   GitHub Page: https://github.com/artsmolin/pythogen
#   Version:     0.2.24
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import datetime
import logging
from dataclasses import dataclass
from typing import IO
from typing import Any
from typing import Literal
from typing import Protocol
from typing import Union

import httpx
from httpx import Timeout
from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import RootModel


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


class MetricsIntegration(Protocol):
    def on_request_error(
        self,
        client_name: str,
        error: Exception,
        http_method: str,
        http_target: str,
    ) -> None:
        ...

    def on_request_success(
        self,
        client_name: str,
        response,
        http_method: str,
        http_target: str,
    ) -> None:
        ...

    def shadow_path(self) -> bool:
        ...


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: dict[str, Any]
    headers: dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class LogsIntegration(Protocol):
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        ...

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        ...

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        ...


class DefaultLogsIntegration:
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"props": {"data": kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = f"request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO


FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    tuple[str | None, FileContent],
    # (filename, file (or text), content_type)
    tuple[str | None, FileContent, str | None],
]


class RequiredHeaders(Exception):
    ...


class EmptyBody(BaseModel):
    status_code: int
    text: str


class FindPetsByStatusQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    status: Literal["available", "pending", "sold"] | None = Field(None, alias="status")


class FindPetsByTagsQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    tags: list[str] | None = Field(None, alias="tags")


class GetPetByIdPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    pet_id: int = Field(alias="petId")


class GetOrderByIdPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    order_id: int = Field(alias="orderId")


class LoginUserQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    username: str | None = Field(None, alias="username")
    password: str | None = Field(None, alias="password")


class GetUserByNamePathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    username: str = Field(alias="username")


class UpdatePetWithFormPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    pet_id: int = Field(alias="petId")


class UpdatePetWithFormQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    name: str | None = Field(None, alias="name")
    status: str | None = Field(None, alias="status")


class UploadFilePathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    pet_id: int = Field(alias="petId")


class UploadFileQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    additional_metadata: str | None = Field(None, alias="additionalMetadata")


class UpdateUserPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    username: str = Field(alias="username")


class DeletePetPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    pet_id: int = Field(alias="petId")


class DeletePetHeaders(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    api_key: str | None = Field(None, alias="api_key")


class DeleteOrderPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    order_id: int = Field(alias="orderId")


class DeleteUserPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    username: str = Field(alias="username")


class LoginuserResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    text: str | None = None


class CreateuserswithlistinputRequestBody(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class GetinventoryResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class UploadfileRequestBody(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    content: bytes | None = None


class FindpetsbytagsResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class FindpetsbystatusResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class AddpetortagRequestBody(RootModel):
    """
    None

    """

    root: list[Pet | Tag]

    def __iter__(self):
        return iter(self.root)

    def __getitem__(self, item):
        return self.root[item]


class AddpetortagResponse200(RootModel):
    """
    None

    """

    root: list[Pet | Tag]

    def __iter__(self):
        return iter(self.root)

    def __getitem__(self, item):
        return self.root[item]


class ApiResponse(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    code: int | None = None
    type: str | None = None
    message: str | None = None


class Tag(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: int | None = None
    name: str | None = None


class Category(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: int | None = None
    name: str | None = None


class Pet(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    name: str
    photoUrls: list[str]
    id: int | None = None
    category: Category | None = None
    tags: list[Tag] | None = None
    status: Literal["available", "pending", "sold"] | None = Field(None, description="pet status in the store")


class User(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: int | None = None
    username: str | None = None
    firstName: str | None = None
    lastName: str | None = None
    email: str | None = None
    password: str | None = None
    phone: str | None = None
    userStatus: int | None = Field(None, description="User Status")


class Address(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    street: str | None = None
    city: str | None = None
    state: str | None = None
    zip: str | None = None


class Customer(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: int | None = None
    username: str | None = None
    address: list[Address] | None = None


class Order(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: int | None = None
    petId: int | None = None
    quantity: int | None = None
    shipDate: datetime.datetime | None = None
    status: Literal["placed", "approved", "delivered"] | None = Field(None, description="Order Status")
    complete: bool | None = None


class BasicAuth(BaseModel):
    username: str
    password: str


class Client:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "",
        client: httpx.Client | None = None,
        headers: dict[str, str] | None = None,
        metrics_integration: MetricsIntegration | None = None,
        logs_integration: LogsIntegration | None = DefaultLogsIntegration(),
    ):
        self.client = client or httpx.Client(timeout=Timeout(timeout))
        self.base_url = base_url
        self.headers = headers or {}
        self.metrics_integration = metrics_integration
        self.logs_integration = logs_integration
        self.client_name = client_name

    def findPetsByStatus(
        self,
        query_params: FindPetsByStatusQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | list[Pet]:
        method = "get"

        path = "/pet/findByStatus"

        url = f"{self.base_url}{path}"

        if isinstance(query_params, FindPetsByStatusQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/findByStatus"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/findByStatus"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [Pet.model_validate(item) for item in response.json()]

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def findPetsByTags(
        self,
        query_params: FindPetsByTagsQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | list[Pet]:
        method = "get"

        path = "/pet/findByTags"

        url = f"{self.base_url}{path}"

        if isinstance(query_params, FindPetsByTagsQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/findByTags"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/findByTags"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [Pet.model_validate(item) for item in response.json()]

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def getPetById(
        self,
        path_params: GetPetByIdPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | Pet:
        method = "get"

        if isinstance(path_params, GetPetByIdPathParams):
            path = "/pet/{petId}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/pet/{petId}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/:petId"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/:petId"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return Pet.model_validate(response.json())

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def getInventory(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> GetinventoryResponse200 | None:
        method = "get"

        path = "/store/inventory"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/store/inventory"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/store/inventory"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetinventoryResponse200.model_validate(response.json())

    def getOrderById(
        self,
        path_params: GetOrderByIdPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | Order:
        method = "get"

        if isinstance(path_params, GetOrderByIdPathParams):
            path = "/store/order/{orderId}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/store/order/{orderId}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/store/order/:orderId"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/store/order/:orderId"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return Order.model_validate(response.json())

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def loginUser(
        self,
        query_params: LoginUserQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | LoginuserResponse200:
        method = "get"

        path = "/user/login"

        url = f"{self.base_url}{path}"

        if isinstance(query_params, LoginUserQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/login"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/login"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return LoginuserResponse200(text=response.text)

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def logoutUser(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> None:
        method = "get"

        path = "/user/logout"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/logout"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/logout"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

    def getUserByName(
        self,
        path_params: GetUserByNamePathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | User:
        method = "get"

        if isinstance(path_params, GetUserByNamePathParams):
            path = "/user/{username}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/user/{username}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/:username"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/:username"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return User.model_validate(response.json())

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def addPet(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: Pet | dict[str, Any] | None = None,
    ) -> EmptyBody | Pet:
        method = "post"

        path = "/pet"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Pet):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return Pet.model_validate(response.json())

        if response.status_code == 405:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def addPetOrTag(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: AddpetortagRequestBody | dict[str, Any] | None = None,
    ) -> AddpetortagResponse200 | EmptyBody:
        method = "post"

        path = "/pet_or_tag"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, AddpetortagRequestBody):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet_or_tag"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet_or_tag"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return AddpetortagResponse200.model_validate(response.json())

        if response.status_code == 405:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def updatePetWithForm(
        self,
        path_params: UpdatePetWithFormPathParams | dict[str, Any],
        query_params: UpdatePetWithFormQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | None:
        method = "post"

        if isinstance(path_params, UpdatePetWithFormPathParams):
            path = "/pet/{petId}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/pet/{petId}".format(**path_params)

        url = f"{self.base_url}{path}"

        if isinstance(query_params, UpdatePetWithFormQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/:petId"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/:petId"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 405:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def uploadFile(
        self,
        path_params: UploadFilePathParams | dict[str, Any],
        query_params: UploadFileQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: bytes | dict[str, Any] | None = None,
    ) -> ApiResponse | None:
        method = "post"

        if isinstance(path_params, UploadFilePathParams):
            path = "/pet/{petId}/uploadImage".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/pet/{petId}/uploadImage".format(**path_params)

        url = f"{self.base_url}{path}"

        if isinstance(query_params, UploadFileQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, bytes):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/:petId/uploadImage"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/:petId/uploadImage"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return ApiResponse.model_validate(response.json())

    def placeOrder(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: Order | dict[str, Any] | None = None,
    ) -> EmptyBody | Order:
        method = "post"

        path = "/store/order"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Order):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/store/order"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/store/order"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return Order.model_validate(response.json())

        if response.status_code == 405:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def createUser(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: User | dict[str, Any] | None = None,
    ) -> None:
        method = "post"

        path = "/user"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, User):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

    def createUsersWithListInput(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: list[User] | dict[str, Any] | None = None,
    ) -> User | None:
        method = "post"

        path = "/user/createWithList"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, list[User]):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/createWithList"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/createWithList"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return User.model_validate(response.json())

    def updatePet(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: Pet | dict[str, Any] | None = None,
    ) -> EmptyBody | Pet:
        method = "put"

        path = "/pet"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, Pet):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return Pet.model_validate(response.json())

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 405:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def updateUser(
        self,
        path_params: UpdateUserPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: User | dict[str, Any] | None = None,
    ) -> None:
        method = "put"

        if isinstance(path_params, UpdateUserPathParams):
            path = "/user/{username}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/user/{username}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, User):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/:username"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/:username"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

    def deletePet(
        self,
        path_params: DeletePetPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: DeletePetHeaders | dict[str, Any] | None = None,
    ) -> EmptyBody | None:
        method = "delete"

        if isinstance(path_params, DeletePetPathParams):
            path = "/pet/{petId}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/pet/{petId}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if isinstance(headers, DeletePetHeaders):
            headers_ = headers.model_dump(by_alias=True, exclude_none=True)
        elif isinstance(headers, dict):
            headers_ = headers

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/pet/:petId"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/pet/:petId"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def deleteOrder(
        self,
        path_params: DeleteOrderPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | None:
        method = "delete"

        if isinstance(path_params, DeleteOrderPathParams):
            path = "/store/order/{orderId}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/store/order/{orderId}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/store/order/:orderId"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/store/order/:orderId"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def deleteUser(
        self,
        path_params: DeleteUserPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
    ) -> EmptyBody | None:
        method = "delete"

        if isinstance(path_params, DeleteUserPathParams):
            path = "/user/{username}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/user/{username}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = self.client.request(method, url, headers=headers_, params=params, content=content, auth=auth_)
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/user/:username"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/user/:username"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 400:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

        if response.status_code == 404:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return EmptyBody(status_code=response.status_code, text=response.text)

    def close(self) -> None:
        self.client.close()

    def _get_url(self, path: str) -> str:
        return f"{self.base_url}{path}"

    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"extra": {"props": {"data": kwargs}}}

    def log_error(self, client_name: str, method, url: str, params, content, headers) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: dict[str, Any], schema_classes: list[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.model_validate(item)
            except:
                continue

        raise Exception('Can\'t parse "{item}"')


LoginuserResponse200.model_rebuild()
CreateuserswithlistinputRequestBody.model_rebuild()
GetinventoryResponse200.model_rebuild()
UploadfileRequestBody.model_rebuild()
FindpetsbytagsResponse200.model_rebuild()
FindpetsbystatusResponse200.model_rebuild()
AddpetortagRequestBody.model_rebuild()
AddpetortagResponse200.model_rebuild()
ApiResponse.model_rebuild()
Tag.model_rebuild()
Category.model_rebuild()
Pet.model_rebuild()
User.model_rebuild()
Address.model_rebuild()
Customer.model_rebuild()
Order.model_rebuild()
