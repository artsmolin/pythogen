# ==============================================================================
#
# {{ name }} (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import abc
from dataclasses import dataclass

from datetime import datetime
from datetime import date

from httpx import Timeout
try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal
from typing import List
from typing import Tuple
from typing import Any
from typing import Dict
from typing import Optional
from typing import Union
from typing import Callable
from typing import get_type_hints
from typing import Mapping
from typing import Sequence
from typing import IO
from typing import cast

{%- if metrics %}
from prometheus_client import Counter
from prometheus_client import Histogram
{%- endif %}
import httpx
from pydantic import BaseModel
from pydantic import Field
from pydantic import root_validator
from pydantic import validator
from pydantic import HttpUrl
import logging
from functools import wraps


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None

{%- if metrics %}
class BaseMetricsIntegration(abc.ABC):
    def __init__(
        self,
        client_response_time_histogram: Optional[Histogram] = None,
        client_non_http_errors_counter: Optional[Counter] = None,
        shadow_path: bool = True,
    ):
        self._client_response_time_histogram = client_response_time_histogram
        self._client_non_http_errors_counter = client_non_http_errors_counter
        self.shadow_path = shadow_path

    @abc.abstractmethod
    def on_request_error(self, client_name: str, error: Exception, http_method: str, http_target: str) -> None: ...

    @abc.abstractmethod
    def on_request_success(self, client_name: str, response, http_method: str, http_target: str) -> None: ...


class DefaultMetricsIntegration(BaseMetricsIntegration):
    def on_request_error(self, client_name: str, error: Exception, http_method: str, http_target: str) -> None:
        self._client_non_http_errors_counter.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            exception=error.__class__.__name__,
        ).inc(1)
        raise error

    def on_request_success(self, client_name: str, response, http_method: str, http_target: str) -> None:
        self._client_response_time_histogram.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            http_status_code=response.status_code,
        ).observe(response.elapsed.total_seconds())
{%- endif %}


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: Dict[str, Any]
    headers: Dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class BaseLogsIntegration(abc.ABC):
    @abc.abstractmethod
    def log_extra(self, **kwargs: Any) -> Dict[str, Any]: ...

    @abc.abstractmethod
    def log_error(self, req: RequestBox, resp: ResponseBox) -> None: ...

    @abc.abstractmethod
    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int: ...


class DefaultLogsIntegration(BaseLogsIntegration):
    def log_extra(self, **kwargs: Any) -> Dict[str, Any]:
        return {'props': {'data': kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = f"request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO

FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    Tuple[Optional[str], FileContent],
    # (filename, file (or text), content_type)
    Tuple[Optional[str], FileContent, Optional[str]],
]


class RequiredHeaders(Exception):
    ...


class EmptyBody(BaseModel):
    status_code: int
    text: str

{% for schema in discriminator_base_class_schemas %}
class {{ schema.name }}(BaseModel):
    {{ schema.attr }}: str

    @validator("{{ schema.attr }}", pre=True)
    def check(cls, v: str) -> str:
        type_hints = get_type_hints(cls)
        {{ schema.attr }}_values: Tuple[str] = type_hints["{{ schema.attr }}"].__dict__['__args__']

        if v not in {{ schema.attr }}_values:
            raise ValueError(f'invalid {{ schema.attr }} for {cls}')

        return v
{%- endfor %}


{%- for model in models %}


class {{ classname(model.id) }}(BaseModel):
    """
    {{ model.title }}
    """

    {%- if model.type.value == "any_of"  %}
    __root__: Union[
    {%- for item in model.items %}
        '{{ item.id }}',
    {%- endfor %}
    ]
    {%- else %}

    # required ---
    {%- for property in model.required_properties %}
        {%- if property.schema.description %}
    {{ property.key }}: {{ typerepr(property.schema, document) }} = Field(description="{{ property.schema.description }}"{%- if property.safety_key %}, alias="{{ property.orig_key }}"{%- endif %})
        {%- else %}
    {{ property.key }}: {{ typerepr(property.schema, document) }}
        {%- endif %}
    {%- endfor %}

    # optional ---
    {%- for property in model.optional_properties %}
        {%- if property.schema.description %}
    {{ property.key }}: Optional[{{ typerepr(property.schema, document) }}] = Field(description="{{ property.schema.description }}"{%- if property.safety_key %}, alias="{{ property.orig_key }}"{%- endif %})
        {%- else %}
    {{ property.key }}: Optional[{{ typerepr(property.schema, document) }}] = None
        {%- endif %}
    {%- endfor %}

    {%- for property in model.required_properties + model.optional_properties if property.safety_key %}

    class Config:
        # Обращение по имени поля, даже если есть алиас.
        allow_population_by_field_name = True
    {%- break %}
    {%- endfor %}

    {%- endif %}
{%- endfor %}


class BasicAuth(BaseModel):
    username: str
    password: str


class {{ name }}:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "{{ name | replace('Client', '') | lower }}",
        {%- if sync %}
        client: Optional[httpx.Client] = None,
        {%- else %}
        client: Optional[httpx.AsyncClient] = None,
        {%- endif %}
        headers: Optional[Dict[str, str]] = None,
        {%- if metrics %}
        metrics_integration: Optional[BaseMetricsIntegration] = None,
        {%- endif %}
        logs_integration: Optional[BaseLogsIntegration] = DefaultLogsIntegration(),
    ):
        {%- if sync %}
        self.client = client or httpx.Client(timeout=Timeout(timeout))
        {%- else %}
        self.client = client or httpx.AsyncClient(timeout=Timeout(timeout))
        {%- endif %}
        self.base_url = base_url
        self.headers = headers or {}
        {%- if metrics %}
        self.metrics_integration=metrics_integration
        {%- endif %}
        self.logs_integration = logs_integration
        self.client_name = client_name
        {% if required_headers %}
        if set({{ required_headers }}) != set(self.headers):
            raise RequiredHeaders("Headers {{ required_headers }} is required")
        {%- endif %}

    {#-  get items begin  #}
    {% with items=get.items(), method='get'%}
    {%- include 'client/httpx-method.j2' %}
    {%- endwith %}
    {#-  get items end  #}
    {#-  post items begin  #}
    {%- with items=post.items(), method='post'%}
    {%- include 'client/httpx-method.j2' %}
    {%- endwith %}
    {#-  post items end  #}
    {#-  patch items begin  #}
    {%- with items=patch.items(), method='patch'%}
    {%- include 'client/httpx-method.j2' %}
    {%- endwith %}
    {#-  patch items end  #}
    {#-  put items begin  #}
    {%- with items=put.items(), method='put'%}
    {%- include 'client/httpx-method.j2' %}
    {%- endwith %}
    {#-  put items end  #}
    {#-  delete_no_body items begin  #}
    {%- with items=delete_no_body.items(), method='delete', body=False %}
    {%- include 'client/httpx-method.j2' %}
    {%- endwith %}
    {#-  delete_no_body items end  #}
    {% if sync %}
    def close(self) -> None:
        self.client.close()
    {%- else %}
    async def close(self) -> None:
        await self.client.aclose()
    {%- endif %}

    def _get_url(self, path: str) -> str:
        return f'{self.base_url}{path}'

    def log_extra(self, **kwargs: Any) -> Dict[str, Any]:
        return {'extra': {'props': {'data': kwargs}}}

    def log_error(self, client_name: str, method, url: str, params, content, headers) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: Dict[str, Any], schema_classes: List[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.parse_obj(item)
            except:
                continue

        raise Exception("Can't parse \"{item}\"")



{% for model in models -%}
{{ classname(model.id) }}.update_forward_refs()
{% endfor %}
