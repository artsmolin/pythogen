# ==============================================================================
#
# {{ name }} (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# Generator info:
#   GitHub Page: https://github.com/artsmolin/pythogen
#   Version:     {{ pythogen_version }}
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import abc
from dataclasses import dataclass

import datetime

from enum import Enum
from enum import IntEnum

from httpx import Timeout
from typing import Literal

from typing import Any

from typing import Union
from typing import Callable
from typing import get_type_hints
from typing import Mapping
from typing import Sequence
from typing import IO
from typing import cast
from typing import Protocol

{%- if metrics %}
from prometheus_client import Counter
from prometheus_client import Histogram
{%- endif %}
import httpx
from pydantic import BaseModel
from pydantic import RootModel
from pydantic import Field
from pydantic import field_validator
from pydantic import ValidationInfo
from pydantic import ConfigDict
from pydantic import HttpUrl
import logging
from functools import wraps


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


class RequestBodySerializer(Protocol):
    def __call__(self, v: Any) -> Any:
        ...


class MetricsIntegration(Protocol):
    def on_request_error(self, client_name: str, error: Exception, http_method: str, http_target: str,) -> None:
        ...

    def on_request_success(self, client_name: str, response, http_method: str, http_target: str,) -> None:
        ...

    def shadow_path(self) -> bool:
        ...


{%- if metrics %}
class DefaultMetricsIntegration:
    def __init__(
        self,
        client_response_time_histogram: Histogram | None = None,
        client_non_http_errors_counter: Counter | None = None,
    ):
        self._client_response_time_histogram = client_response_time_histogram
        self._client_non_http_errors_counter = client_non_http_errors_counter

    def on_request_error(self, client_name: str, error: Exception, http_method: str, http_target: str) -> None:
        self._client_non_http_errors_counter.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            exception=error.__class__.__name__,
        ).inc(1)
        raise error

    def on_request_success(self, client_name: str, response, http_method: str, http_target: str) -> None:
        self._client_response_time_histogram.labels(
            client_name=client_name,
            http_method=http_method,
            http_target=http_target,
            http_status_code=response.status_code,
        ).observe(response.elapsed.total_seconds())

    def shadow_path(self) -> bool:
        return True
{%- endif %}


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: dict[str, Any]
    headers: dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class LogsIntegration(Protocol):
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        ...

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        ...

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        ...


class DefaultLogsIntegration:
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {'props': {'data': kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = f"request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO

FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    tuple[str | None, FileContent],
    # (filename, file (or text), content_type)
    tuple[str | None, FileContent, str | None],
]


class RequiredHeaders(Exception):
    ...


{%- for enum_class in enums %}
{%- if enum_class.type.value == "integer"  %}
class {{ classname(enum_class.id) }}(IntEnum):
    """
    {{ enum_class.title }}
    """
    {%- for val in enum_class.enum %}
    _{{ val }} = {{ val }}
    {%- endfor %}
{%- else %}
class {{ classname(enum_class.id) }}(str, Enum):
    """
    {{ enum_class.title }}
    """
    {%- for val in enum_class.enum %}
    {{ varname(val).upper() }} = "{{ val }}"
    {%- endfor %}

    def __str__(self) -> Any:
        return self.value
{%- endif %}
{%- endfor %}

class EmptyBody(BaseModel):
    status_code: int
    text: str


{% include 'operation_params_schemas.j2' %}

{% for schema in discriminator_base_class_schemas %}
class {{ schema.name }}(BaseModel):
    {{ schema.attr }}: str

    @field_validator("{{ schema.attr }}", mode='before')
    def check(cls, v: str, info: ValidationInfo) -> str:
        type_hints = get_type_hints(cls)
        {{ schema.attr }}_values: tuple[str] = type_hints["{{ schema.attr }}"].__dict__['__args__']

        if v not in {{ schema.attr }}_values:
            raise ValueError(f'invalid {{ schema.attr }} for {cls}')

        return v
{%- endfor %}


{%- for model in models %}

{%- if model.type.value == "null"  %}
{%- elif model.is_empty_object  %}
{%- elif model.any_of  %}
class {{ classname(model.id) }}(RootModel):
    """
    {{ model.title }}
    {{ model.description }}
    """
    root: {{ repranyof(model.any_of, document) }}
{%- elif model.all_of %}
class {{ classname(model.id) }}(
    {% for all_of_item_model in model.named_allof_models %}{{ typerepr(all_of_item_model, document) }},{% endfor %}
):
    """
    {{ model.title }}
    {{ model.description }}
    """
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    {% for all_of_item_model in model.inline_allof_models %}
    {%- for property in all_of_item_model.required_properties %}
    {{ property.key }}: {{ typerepr(property.schema, document) }} {{ propertyfield(property, model) }}
    {%- endfor %}

    {%- for property in all_of_item_model.optional_properties %}
    {{ property.key }}: {{ typerepr(property.schema, document) }} | None {{ propertyfield(property, model) }}
    {%- endfor %}

    {%- for property in all_of_item_model.required_properties + all_of_item_model.optional_properties if property.safety_key %}
    {%- break %}
    {%- endfor %}
    {% endfor %}
    ...
{%- else %}
class {{ classname(model.id) }}(BaseModel):
    """
    {{ model.title }}
    {{ model.description }}
    """
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    {%- for property in model.required_properties %}
    {{ property.key }}: {{ typerepr(property.schema, document) }} {{ propertyfield(property, model) }}
    {%- endfor %}

    {%- for property in model.optional_properties %}
    {{ property.key }}: {{ typerepr(property.schema, document) }} | None {{ propertyfield(property, model) }}
    {%- endfor %}

    {%- for property in model.required_properties + model.optional_properties if property.safety_key %}
    {%- break %}
    {%- endfor %}
{% endif %}

{%- endfor %}


class BasicAuth(BaseModel):
    username: str
    password: str


class PythogenMetaBox(BaseModel):
    request: RequestBox | None = None
    response: ResponseBox | None = None



class {{ name }}:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "{{ name | replace('Client', '') | lower }}",
        {%- if sync %}
        client: httpx.Client | None = None,
        {%- else %}
        client: httpx.AsyncClient | None = None,
        {%- endif %}
        headers: dict[str, str] | None = None,
        metrics_integration: MetricsIntegration | None = None,
        logs_integration: LogsIntegration | None = DefaultLogsIntegration(),
    ):
        """
        Parameters
        ----------
        base_url
            Base URL
        timeout
            In seconds
        client_name
            Used in metrics
        client
            httpx-client
        headers
            Headers that will be passed in all requests
        metrics_integration
            The object that is responsible for collecting and sending metrics
        logs_integration
            The object that is responsible for logging events
        """
        {%- if sync %}
        self.client = client or httpx.Client(timeout=Timeout(timeout))
        {%- else %}
        self.client = client or httpx.AsyncClient(timeout=Timeout(timeout))
        {%- endif %}
        self.base_url = base_url
        self.headers = headers or {}
        self.metrics_integration = metrics_integration
        self.logs_integration = logs_integration
        self.client_name = client_name
        {% if required_headers %}
        if set({{ required_headers }}) != set(self.headers):
            raise RequiredHeaders("Headers {{ required_headers }} is required")
        {%- endif %}

    {#-  get items begin  #}
    {% with items=get.items(), method='get'%}
    {%- include 'method.j2' %}
    {%- endwith %}
    {#-  get items end  #}
    {#-  post items begin  #}
    {%- with items=post.items(), method='post'%}
    {%- include 'method.j2' %}
    {%- endwith %}
    {#-  post items end  #}
    {#-  patch items begin  #}
    {%- with items=patch.items(), method='patch'%}
    {%- include 'method.j2' %}
    {%- endwith %}
    {#-  patch items end  #}
    {#-  put items begin  #}
    {%- with items=put.items(), method='put'%}
    {%- include 'method.j2' %}
    {%- endwith %}
    {#-  put items end  #}
    {#-  delete_no_body items begin  #}
    {%- with items=delete_no_body.items(), method='delete', body=False %}
    {%- include 'method.j2' %}
    {%- endwith %}
    {#-  delete_no_body items end  #}
    {% if sync %}
    def close(self) -> None:
        self.client.close()
    {%- else %}
    async def close(self) -> None:
        await self.client.aclose()
    {%- endif %}

    def _get_url(self, path: str) -> str:
        return f'{self.base_url}{path}'

    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {'extra': {'props': {'data': kwargs}}}

    def log_error(self, client_name: str, method, url: str, params, content, headers) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: dict[str, Any], schema_classes: list[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.model_validate(item)
            except:
                continue

        raise Exception("Can't parse \"{item}\"")



{% for model in models %}
{%- if model.type.value not in ("any_of", "null") and not model.is_empty_object %}
{{ classname(model.id) }}.model_rebuild()
{%- else %}
{%- endif -%}
{% endfor %}
