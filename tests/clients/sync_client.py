# ==============================================================================
#
# Client (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import abc
from dataclasses import dataclass

from datetime import datetime
from datetime import date

from httpx import Timeout

try:
    from typing import Literal
except ImportError:
    from typing_extensions import Literal

from typing import Tuple
from typing import Any

from typing import Union
from typing import Callable
from typing import get_type_hints
from typing import Mapping
from typing import Sequence
from typing import IO
from typing import cast
import httpx
from pydantic import BaseModel
from pydantic import Field
from pydantic import root_validator
from pydantic import validator
from pydantic import HttpUrl
import logging
from functools import wraps


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: dict[str, Any]
    headers: dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class BaseLogsIntegration(abc.ABC):
    @abc.abstractmethod
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        ...

    @abc.abstractmethod
    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        ...

    @abc.abstractmethod
    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        ...


class DefaultLogsIntegration(BaseLogsIntegration):
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"props": {"data": kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = f"request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO


FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    tuple[str | None, FileContent],
    # (filename, file (or text), content_type)
    tuple[str | None, FileContent, str | None],
]


class RequiredHeaders(Exception):
    ...


class EmptyBody(BaseModel):
    status_code: int
    text: str


class BaseObjectResp(BaseModel):
    string_data: str

    @validator("string_data", pre=True)
    def check(cls, v: str) -> str:
        type_hints = get_type_hints(cls)
        string_data_values: Tuple[str] = type_hints["string_data"].__dict__["__args__"]

        if v not in string_data_values:
            raise ValueError(f"invalid string_data for {cls}")

        return v


class PostObjectWithRequestBodyAnyOfRequestBody(BaseModel):
    """
    None
    """

    __root__: Union[
        "Data",
        "PostObjectData",
    ]


class AllOfRefObj(BaseModel):
    """
    All Of
    """

    # required ---

    # optional ---
    id: str | None = None
    data: int | None = None


class GetBinaryResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    content: bytes | None = None


class GetTextAsIntegerResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    text: int | None = None


class GetTextResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    text: str | None = None


class GetlistobjectsResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---


class RewardsListItem(BaseModel):
    """
    None
    """

    # required ---
    pricePlanCode: str
    quantity: float

    # optional ---


class GetObjectWithInlineArrayResponse200(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    rewards: list[RewardsListItem] | None = None


class GetObjectWithInlineArrayResponse200Item(BaseModel):
    """
    None
    """

    # required ---
    pricePlanCode: str
    quantity: float

    # optional ---


class AnimalObj(BaseModel):
    """
    None
    """

    __root__: Union[
        "Cat",
        "Dog",
    ]


class AnyOfChildObj(BaseModel):
    """
    None
    """

    __root__: Union[
        "GetObjectResp",
        "Cat",
    ]


class TierObj(BaseModel):
    """
    None
    """

    # required ---

    # optional ---
    code: str | None = None
    name: str | None = None
    priority: int | None = None


class GetObjectNoRefSchemaResponse200(BaseModel):
    """
    GetObjectResp
    """

    # required ---

    # optional ---
    string_data: str | None = Field(
        description="String Data. [__discriminator__(BaseObjectResp.string_data)]"
    )
    integer_data: int | None = None
    array_data: list[str] | None = None
    boolean_data: bool | None = None


class TestSafetyKey(BaseModel):
    """
    model for testing safety key
    """

    # required ---

    # optional ---
    for_: str | None = Field(description='reserved word, expecting "for_"', alias="for")
    class_: str | None = Field(
        description='reserved word, expecting "class_"', alias="class"
    )
    with_dot_and_hyphens: int | None = Field(
        description='invalid identifier, expecting "with_dot_and_hyphens"',
        alias="33with.dot-and-hyphens&*",
    )
    old_feature_priority: int | None = Field(
        description='__safety_key__(old_feature_priority) invalid identifier, expecting "old_feature_priority"',
        alias="34with.dot-and-hyphens&*",
    )

    class Config:
        # Обращение по имени поля, даже если есть алиас.
        allow_population_by_field_name = True


class UnknownError(BaseModel):
    """
    UnknownError
    """

    # required ---

    # optional ---
    code: str | None = None


class DeleteObjectResp(BaseModel):
    """
    DeleteObjectResp
    """

    # required ---

    # optional ---
    status: str | None = None


class PutObjectResp(BaseModel):
    """
    PutObjectResp
    """

    # required ---

    # optional ---
    status: str | None = None


class PatchObjectResp(BaseModel):
    """
    PatchObjectResp
    """

    # required ---

    # optional ---
    status: str | None = None


class PostObjectResp(BaseModel):
    """
    PostObjectResp
    """

    # required ---

    # optional ---
    status: str | None = None


class PostFile(BaseModel):
    """
    PostFile
    """

    # required ---
    text: str

    # optional ---


class PutObjectData(BaseModel):
    """
    PutObjectData
    """

    # required ---
    id: str
    data: int

    # optional ---


class PatchObjectData(BaseModel):
    """
    PatchObjectData
    """

    # required ---
    id: str
    data: int

    # optional ---


class PostObjectData(BaseModel):
    """
    PostObjectData
    """

    # required ---
    string_data: str
    integer_data: int
    array_data: list[str]
    boolean_data: bool
    event_data: dict = Field(
        description="__safety_key__(event_data)", alias="event-data"
    )

    # optional ---
    date: date | None = None
    datetime: datetime | None = None
    url: HttpUrl | None = None

    class Config:
        # Обращение по имени поля, даже если есть алиас.
        allow_population_by_field_name = True


class Dog(BaseModel):
    """
    Dog
    """

    # required ---

    # optional ---
    name: str | None = None


class Cat(BaseModel):
    """
    Cat
    """

    # required ---

    # optional ---
    name: str | None = None


class GetObjectResp(BaseModel):
    """
    GetObjectResp
    """

    # required ---

    # optional ---
    string_data: str | None = Field(
        description="String Data. [__discriminator__(BaseObjectResp.string_data)]"
    )
    integer_data: int | None = None
    array_data: list[str] | None = None
    boolean_data: bool | None = None
    tier: TierObj | None = None
    anyOfChild: AnyOfChildObj | None = None
    child: GetObjectResp | None = None
    childs: list[GetObjectResp] | None = None
    animal: AnimalObj | None = None


class Data(BaseModel):
    """
    Data
    """

    # required ---

    # optional ---
    id: str | None = None
    data: int | None = None


class AllOfResp(BaseModel):
    """
    All Of Resp
    """

    # required ---

    # optional ---
    all_of: AllOfRefObj | None = None


class BasicAuth(BaseModel):
    username: str
    password: str


class Client:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "",
        client: httpx.Client | None = None,
        headers: dict[str, str] | None = None,
        logs_integration: BaseLogsIntegration | None = DefaultLogsIntegration(),
    ):
        self.client = client or httpx.Client(timeout=Timeout(timeout))
        self.base_url = base_url
        self.headers = headers or {}
        self.logs_integration = logs_integration
        self.client_name = client_name

    def get_object_no_ref_schema(
        self,
        object_id: str,
        from_: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectNoRefSchemaResponse200 | None:
        url = self._get_url(f"/objects/no-ref-schema/{object_id}")

        params = {
            "from": from_,
        }
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectNoRefSchemaResponse200.parse_obj(response.json())

    def get_object(
        self,
        object_id: str,
        from_: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectResp | UnknownError:
        url = self._get_url(f"/objects/{object_id}")

        params = {
            "from": from_,
        }
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectResp.parse_obj(response.json())

        if response.status_code == 500:
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.parse_obj(response.json())

    def get_object_with_inline_array(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> list[GetObjectWithInlineArrayResponse200Item] | None:
        url = self._get_url(f"/object-with-array-response")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [
                GetObjectWithInlineArrayResponse200Item.parse_obj(item)
                for item in response.json()
            ]

    def get_object_with_inline_array(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectWithInlineArrayResponse200 | None:
        url = self._get_url(f"/object-with-inline-array")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectWithInlineArrayResponse200.parse_obj(response.json())

    def get_list_objects(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> list[GetObjectResp] | None:
        url = self._get_url(f"/objects")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return [GetObjectResp.parse_obj(item) for item in response.json()]

    def get_text(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetTextResponse200 | None:
        url = self._get_url(f"/text")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetTextResponse200(text=response.text)

    def get_text_as_integer(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetTextAsIntegerResponse200 | None:
        url = self._get_url(f"/text_as_integer")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetTextAsIntegerResponse200(text=response.text)

    def get_empty(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> EmptyBody | None:
        url = self._get_url(f"/empty")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return EmptyBody(status_code=response.status_code, text=response.text)

    def get_binary(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetBinaryResponse200 | None:
        url = self._get_url(f"/binary")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetBinaryResponse200(content=response.content)

    def get_allof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> AllOfResp | None:
        url = self._get_url(f"/allof")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return AllOfResp.parse_obj(response.json())

    def get_object_slow(
        self,
        object_id: str,
        return_error: str | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> GetObjectResp | UnknownError:
        url = self._get_url(f"/slow/objects/{object_id}")

        params = {}
        if return_error is not None:
            params["return_error"] = return_error

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "get", url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="get",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return GetObjectResp.parse_obj(response.json())

        if response.status_code == 500:
            method = "get"
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.parse_obj(response.json())

    def post_object_without_body(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/post-without-body")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "post",
                url,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.parse_obj(response.json())

    def post_object(
        self,
        body: PostObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/objects")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.dict(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "post",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.parse_obj(response.json())

    def post_form_object(
        self,
        body: PostObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/objects-form-data")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.dict(by_alias=True)
        else:
            json = None

        headers_.update({"Content-Type": "application/x-www-form-urlencoded"})
        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "post",
                url,
                data=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.parse_obj(response.json())

    def post_multipart_form_data(
        self,
        body: PostFile | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        files: Mapping[str, FileTypes] | Sequence[tuple[str, FileTypes]] | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/multipart-form-data")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostFile):
            json = body.dict(by_alias=True)
        else:
            json = None

        # Content-Type=multipart/form-data doesn't work, because header MUST contain boundaries
        # let library do it for us
        headers_.pop("Content-Type", None)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "post",
                url,
                data=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
                files=files,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.parse_obj(response.json())

    def request_body_anyof(
        self,
        body: PostObjectWithRequestBodyAnyOfRequestBody | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PostObjectResp | None:
        url = self._get_url(f"/request-body-anyof")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectWithRequestBodyAnyOfRequestBody):
            json = body.dict(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "post",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="post",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PostObjectResp.parse_obj(response.json())

    def patch_object(
        self,
        object_id: str,
        body: PatchObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PatchObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PatchObjectData):
            json = body.dict(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "patch",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="patch",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PatchObjectResp.parse_obj(response.json())

    def put_object(
        self,
        object_id: str,
        body: PutObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PutObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.dict(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "put",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="put",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PutObjectResp.parse_obj(response.json())

    def put_object_slow(
        self,
        object_id: str,
        body: PutObjectData | dict[str, Any] | None = None,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> PutObjectResp | None:
        url = self._get_url(f"/slow/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.dict(by_alias=True)
        else:
            json = None

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "put",
                url,
                json=json,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="put",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return PutObjectResp.parse_obj(response.json())

    def delete_object(
        self,
        object_id: str,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: dict[str, Any] | None = None,
    ) -> DeleteObjectResp | None:
        url = self._get_url(f"/objects/{object_id}")

        params = {}

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if headers:
            headers_ = headers
        try:
            response = self.client.request(
                "delete",
                url,
                headers=headers_,
                params=params,
                content=content,
                auth=auth_,
            )
        except Exception as exc:
            raise exc

        req = RequestBox(
            client_name=self.client_name,
            method="delete",
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if response.status_code == 200:
            return DeleteObjectResp.parse_obj(response.json())

    def close(self) -> None:
        self.client.close()

    def _get_url(self, path: str) -> str:
        return f"{self.base_url}{path}"

    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"extra": {"props": {"data": kwargs}}}

    def log_error(
        self, client_name: str, method, url: str, params, content, headers
    ) -> None:
        msg = f"request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: dict[str, Any], schema_classes: list[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.parse_obj(item)
            except:
                continue

        raise Exception('Can\'t parse "{item}"')


PostObjectWithRequestBodyAnyOfRequestBody.update_forward_refs()
AllOfRefObj.update_forward_refs()
GetBinaryResponse200.update_forward_refs()
GetTextAsIntegerResponse200.update_forward_refs()
GetTextResponse200.update_forward_refs()
GetlistobjectsResponse200.update_forward_refs()
RewardsListItem.update_forward_refs()
GetObjectWithInlineArrayResponse200.update_forward_refs()
GetObjectWithInlineArrayResponse200Item.update_forward_refs()
AnimalObj.update_forward_refs()
AnyOfChildObj.update_forward_refs()
TierObj.update_forward_refs()
GetObjectNoRefSchemaResponse200.update_forward_refs()
TestSafetyKey.update_forward_refs()
UnknownError.update_forward_refs()
DeleteObjectResp.update_forward_refs()
PutObjectResp.update_forward_refs()
PatchObjectResp.update_forward_refs()
PostObjectResp.update_forward_refs()
PostFile.update_forward_refs()
PutObjectData.update_forward_refs()
PatchObjectData.update_forward_refs()
PostObjectData.update_forward_refs()
Dog.update_forward_refs()
Cat.update_forward_refs()
GetObjectResp.update_forward_refs()
Data.update_forward_refs()
AllOfResp.update_forward_refs()
