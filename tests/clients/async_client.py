# ==============================================================================
#
# Client (HTTP-client)
#
# This file was generated by a code generator.
# Don't make changes to it manually.
#
# Generator info:
#   GitHub Page: https://github.com/artsmolin/pythogen
#   Version:     0.2.31
# ==============================================================================

# jinja2: lstrip_blocks: "True"
# mypy: ignore-errors

from __future__ import annotations

import datetime
import logging
from dataclasses import dataclass
from enum import Enum
from enum import IntEnum
from typing import IO
from typing import Any
from typing import Literal
from typing import Mapping
from typing import Protocol
from typing import Sequence
from typing import Union
from typing import get_type_hints

import httpx
from httpx import Timeout
from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field
from pydantic import FieldValidationInfo
from pydantic import HttpUrl
from pydantic import RootModel
from pydantic import field_validator


# backward compatibility for httpx<0.18.2
try:
    DEFAULT_AUTH = httpx.USE_CLIENT_DEFAULT
except AttributeError:
    DEFAULT_AUTH = None


class MetricsIntegration(Protocol):
    def on_request_error(
        self,
        client_name: str,
        error: Exception,
        http_method: str,
        http_target: str,
    ) -> None:
        ...

    def on_request_success(
        self,
        client_name: str,
        response,
        http_method: str,
        http_target: str,
    ) -> None:
        ...

    def shadow_path(self) -> bool:
        ...


@dataclass
class RequestBox:
    client_name: str
    method: str
    url: str
    params: dict[str, Any]
    headers: dict[str, Any]
    content: Any


@dataclass
class ResponseBox:
    status_code: int


class LogsIntegration(Protocol):
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        ...

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        ...

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        ...


class DefaultLogsIntegration:
    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"props": {"data": kwargs}}

    def log_error(self, req: RequestBox, resp: ResponseBox) -> None:
        msg = "request error"
        msg += f" | client={req.client_name}"
        msg += f" | method={req.method}"
        msg += f" | url={req.url}"
        msg += f" | params={req.params}"
        msg += f" | content={req.content}"
        msg += f" | headers={req.headers}"

        level = self.get_log_error_level(req, resp)

        logging.log(
            level,
            msg,
            extra=self.log_extra(
                client=req.client_name,
                method=req.method,
                content=req.content,
                url=req.url,
                params=req.params,
            ),
        )

    def get_log_error_level(self, req: RequestBox, resp: ResponseBox) -> int:
        if resp.status_code >= 500:
            return logging.ERROR
        elif resp.status_code >= 400:
            return logging.WARNING
        elif resp.status_code >= 300:
            return logging.INFO
        elif resp.status_code >= 200:
            return logging.INFO
        else:
            return logging.INFO


FileContent = Union[IO[str], IO[bytes], str, bytes]
FileTypes = Union[
    # file (or text)
    FileContent,
    # (filename, file (or text))
    tuple[str | None, FileContent],
    # (filename, file (or text), content_type)
    tuple[str | None, FileContent, str | None],
]


class RequiredHeaders(Exception):
    ...


class StringEnum(str, Enum):
    """
    StringEnum
    """

    FIRST_FIELD = "first-field"
    SECOND_FIELD = "second field"

    def __str__(self) -> Any:
        return self.value


class IntegerEnum(IntEnum):
    """
    IntegerEnum
    """

    _1 = 1
    _2 = 2
    _3 = 3
    _4 = 4
    _5 = 5
    _6 = 6


class EmptyBody(BaseModel):
    status_code: int
    text: str


class GetMessageHeaders(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    x_auth_token: str = Field(alias="X-Auth-Token")


class GetObjectNoRefSchemaPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class GetObjectNoRefSchemaQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    from_: str = Field(alias="from", description="__safety_key__(from_)")

    return_error: str | None = Field(None, alias="return_error")


class GetObjectPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class GetObjectQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    from_: str = Field(alias="from", description="__safety_key__(from_)")

    return_error: str | None = Field(None, alias="return_error")


class GetEmptyHeaders(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    first_header: str = Field(alias="first-header")


class GetNoOperationIdHeaders(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    first_header: str = Field(alias="first-header")


class GetObjectSlowPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class GetObjectSlowQueryParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    return_error: str | None = Field(None, alias="return_error")


class PutObjectPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class PutObjectSlowPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class PatchObjectPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class DeleteObjectPathParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    object_id: str = Field(alias="object_id")


class BaseObjectResp(BaseModel):
    string_data: str

    @field_validator("string_data", mode="before")
    def check(cls, v: str, info: FieldValidationInfo) -> str:
        type_hints = get_type_hints(cls)
        string_data_values: tuple[str] = type_hints["string_data"].__dict__["__args__"]

        if v not in string_data_values:
            raise ValueError(f"invalid string_data for {cls}")

        return v


class RequestBodyAnyofRequestBody(RootModel):
    """
    None

    """

    root: Data | PostObjectData


class GetListObjectsResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class RewardsListItem(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    pricePlanCode: str = Field(..., alias="pricePlanCode")
    quantity: float


class GetObjectWithInlineArrayResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    rewards: list[RewardsListItem] | None = None


class GetObjectWithArrayResponseResponse200(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )


class GetObjectWithArrayResponseResponse200Item(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    pricePlanCode: str = Field(..., alias="pricePlanCode")
    quantity: float


class GetObjectNoRefSchemaResponse200(BaseModel):
    """
    GetObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    string_data: str | None = Field(None, description="String Data. [__discriminator__(BaseObjectResp.string_data)]")
    integer_data: int | None = None
    array_data: list[str] | None = None
    boolean_data: bool | None = None


class IntEnumOrNullObj(RootModel):
    """
    None

    """

    root: int | None


class OptionalAnyofStringDataObj(RootModel):
    """
    None

    """

    root: str | None


class AnimalObj(RootModel):
    """
    None

    """

    root: Cat | Dog


class AnyOfChildObj(RootModel):
    """
    None

    """

    root: GetObjectResp | Cat


class TierObj(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    code: str | None = None
    name: str | None = None
    priority: int | None = None


class AllOfRefObjItem2(BaseModel):
    """
    None

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    bark: bool | None = None
    breed: Literal["Dingo", "Husky", "Retriever", "Shepherd"] | None = None


class Cat(BaseModel):
    """
    Cat

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    name: str | None = None


class Data(BaseModel):
    """
    Data

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: str | None = None
    data: int | None = None


class AllOfRefObj(
    Data,
    Cat,
):
    """
    All Of

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )

    bark: bool | None = None
    breed: Literal["Dingo", "Husky", "Retriever", "Shepherd"] | None = None

    ...


class AnyOfChildItem(RootModel):
    """
    AnyOfChildItem

    """

    root: Dog | Cat | int


class ListAnyOfResp(BaseModel):
    """
    PostObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    anyOfChildArray: list[Dog | Cat | int] | None = Field(None, alias="anyOfChildArray")


class SafetyKeyForTesting(BaseModel):
    """
    model for testing safety key

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    for_: str | None = Field(None, alias="for", description='reserved word, expecting "for_"')
    class_: str | None = Field(None, alias="class", description='reserved word, expecting "class_"')
    with_dot_and_hyphens: int | None = Field(
        None, alias="33with.dot-and-hyphens&*", description='invalid identifier, expecting "with_dot_and_hyphens"'
    )
    old_feature_priority: int | None = Field(
        None,
        alias="34with.dot-and-hyphens&*",
        description='__safety_key__(old_feature_priority) invalid identifier, expecting "old_feature_priority"',
    )


class UnknownError(BaseModel):
    """
    UnknownError

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    code: str | None = None
    loc: list[str | int] | None = None


class DeleteObjectResp(BaseModel):
    """
    DeleteObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    status: str | None = None


class PutObjectResp(BaseModel):
    """
    PutObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    status: str | None = None


class PatchObjectResp(BaseModel):
    """
    PatchObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    status: str | None = None


class PostObjectResp(BaseModel):
    """
    PostObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    status: str | None = None


class PostFile(BaseModel):
    """
    PostFile

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    text: str


class PutObjectData(BaseModel):
    """
    PutObjectData

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: str
    data: int


class PatchObjectData(BaseModel):
    """
    Patch-Object_Data

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    id: str
    data: int


class PostObjectData(BaseModel):
    """
    PostObjectData

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    string_data: str
    integer_data: int
    array_data: list[str]
    boolean_data: bool
    event_data: dict = Field(..., alias="event-data", description="__safety_key__(event_data)")
    optional_anyof_string_data: OptionalAnyofStringDataObj | None = None
    date_attr: datetime.date | None = None
    datetime_attr: datetime.datetime | None = None
    url: HttpUrl | None = None
    int_enum: IntegerEnum | None = Field(None, description="An enumeration.")
    str_enum: StringEnum | None = Field(None, description="An enumeration.")
    int_enum_or_null: IntEnumOrNullObj | None = None


class GetObjectResp(BaseModel):
    """
    GetObjectResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    string_data: str | None = Field(None, description="String Data. [__discriminator__(BaseObjectResp.string_data)]")
    integer_data: int | None = None
    array_data: list[str] | None = None
    array_with_anyof: dict | None = None
    boolean_data: bool | None = None
    tier: TierObj | None = None
    anyOfChild: AnyOfChildObj | None = Field(None, alias="anyOfChild")
    child: GetObjectResp | None = None
    childs: list[GetObjectResp] | None = None
    animal: AnimalObj | None = None


class GetMessageResp(BaseModel):
    """
    GetMessageResp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    title: str | None = None
    text: str | None = None


class Dog(BaseModel):
    """
    Dog

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    name: str | None = None


class DogWithKind(BaseModel):
    """
    Dog

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    kind: Literal["dog"]
    name: str


class CatWithKind(BaseModel):
    """
    Cat

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    kind: Literal["cat"]
    name: str


class DiscriminatedOneOfResp(BaseModel):
    """
    All Of Resp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    required_discriminated_animal: CatWithKind | DogWithKind = Field(..., discriminator="kind")
    discriminated_animal: CatWithKind | DogWithKind | None = Field(None, discriminator="kind")


class AllOfResp(BaseModel):
    """
    All Of Resp

    """

    model_config = ConfigDict(
        populate_by_name=True,  # Addressing by field name, even if there is an alias.
    )
    all_of: AllOfRefObj | None = None


class BasicAuth(BaseModel):
    username: str
    password: str


class PythogenMetaBox(BaseModel):
    request: RequestBox | None = None
    response: ResponseBox | None = None


class Client:
    def __init__(
        self,
        base_url: str,
        timeout: int = 5,
        client_name: str = "",
        client: httpx.AsyncClient | None = None,
        headers: dict[str, str] | None = None,
        metrics_integration: MetricsIntegration | None = None,
        logs_integration: LogsIntegration | None = DefaultLogsIntegration(),
    ):
        """
        Parameters
        ----------
        base_url
            Base URL
        timeout
            In seconds
        client_name
            Used in metrics
        client
            httpx-client
        headers
            Headers that will be passed in all requests
        metrics_integration
            The object that is responsible for collecting and sending metrics
        logs_integration
            The object that is responsible for logging events
        """
        self.client = client or httpx.AsyncClient(timeout=Timeout(timeout))
        self.base_url = base_url
        self.headers = headers or {}
        self.metrics_integration = metrics_integration
        self.logs_integration = logs_integration
        self.client_name = client_name

    async def getMessage(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: GetMessageHeaders | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> GetMessageResp | None:
        """
        GET /messages
        Operation ID: getMessage
        Summary:      Get message
        Description:  None
        """

        method = "get"

        path = "/messages"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if isinstance(headers, GetMessageHeaders):
            headers_ = headers.model_dump(by_alias=True, exclude_none=True)
        elif isinstance(headers, dict):
            headers_ = headers

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/messages"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/messages"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return GetMessageResp.model_validate(response.json())

    async def get_object_no_ref_schema(
        self,
        path_params: GetObjectNoRefSchemaPathParams | dict[str, Any],
        query_params: GetObjectNoRefSchemaQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> GetObjectNoRefSchemaResponse200 | None:
        """
        GET /objects/no-ref-schema/{object_id}
        Operation ID: get_object_no_ref_schema
        Summary:      Get Object No Ref Schema
        Description:  None
        """

        method = "get"

        if isinstance(path_params, GetObjectNoRefSchemaPathParams):
            path = "/objects/no-ref-schema/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/objects/no-ref-schema/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        if isinstance(query_params, GetObjectNoRefSchemaQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects/no-ref-schema/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects/no-ref-schema/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return GetObjectNoRefSchemaResponse200.model_validate(response.json())

    async def get_object(
        self,
        path_params: GetObjectPathParams | dict[str, Any],
        query_params: GetObjectQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> GetObjectResp | UnknownError:
        """
        GET /objects/{object_id}
        Operation ID: get_object
        Summary:      Get Object
        Description:  None
        """

        method = "get"

        if isinstance(path_params, GetObjectPathParams):
            path = "/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        if isinstance(query_params, GetObjectQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return GetObjectResp.model_validate(response.json())

        if response.status_code == 500:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.model_validate(response.json())

    async def get_object_with_array_response(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> list[GetObjectWithArrayResponseResponse200Item] | None:
        """
        GET /object-with-array-response
        Operation ID: get_object_with_array_response
        Summary:      Get Object With Inline Array
        Description:  None
        """

        method = "get"

        path = "/object-with-array-response"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/object-with-array-response"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/object-with-array-response"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return [GetObjectWithArrayResponseResponse200Item.model_validate(item) for item in response.json()]

    async def get_object_with_inline_array(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> GetObjectWithInlineArrayResponse200 | None:
        """
        GET /object-with-inline-array
        Operation ID: get_object_with_inline_array
        Summary:      Get Object With Inline Array
        Description:  None
        """

        method = "get"

        path = "/object-with-inline-array"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/object-with-inline-array"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/object-with-inline-array"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return GetObjectWithInlineArrayResponse200.model_validate(response.json())

    async def get_list_objects(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> list[GetObjectResp] | None:
        """
        GET /objects
        Operation ID: get_list_objects
        Summary:      Get list objects
        Description:  None
        """

        method = "get"

        path = "/objects"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return [GetObjectResp.model_validate(item) for item in response.json()]

    async def get_text(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> str | None:
        """
        GET /text
        Operation ID: get_text
        Summary:      Get Text
        Description:  None
        """

        method = "get"

        path = "/text"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/text"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/text"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return response.text

    async def get_text_as_integer(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> int | None:
        """
        GET /text_as_integer
        Operation ID: get_text_as_integer
        Summary:      Get Text As Integer
        Description:  None
        """

        method = "get"

        path = "/text_as_integer"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/text_as_integer"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/text_as_integer"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return int(response.text)

    async def get_empty(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: GetEmptyHeaders | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> EmptyBody | None:
        """
        GET /empty
        Operation ID: get_empty
        Summary:      Get Empty
        Description:  None
        """

        method = "get"

        path = "/empty"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if isinstance(headers, GetEmptyHeaders):
            headers_ = headers.model_dump(by_alias=True, exclude_none=True)
        elif isinstance(headers, dict):
            headers_ = headers

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/empty"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/empty"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return EmptyBody(status_code=response.status_code, text=response.text)

    async def get_no_operation_id(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        headers: GetNoOperationIdHeaders | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> EmptyBody | None:
        """
        GET /no-operation-id
        Operation ID: None
        Summary:      No operation ID
        Description:  None
        """

        method = "get"

        path = "/no-operation-id"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if isinstance(headers, GetNoOperationIdHeaders):
            headers_ = headers.model_dump(by_alias=True, exclude_none=True)
        elif isinstance(headers, dict):
            headers_ = headers

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/no-operation-id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/no-operation-id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return EmptyBody(status_code=response.status_code, text=response.text)

    async def get_binary(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> bytes | None:
        """
        GET /binary
        Operation ID: get_binary
        Summary:      Get Binary
        Description:  None
        """

        method = "get"

        path = "/binary"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/binary"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/binary"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return response.content

    async def get_allof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> AllOfResp | None:
        """
        GET /allof
        Operation ID: get_allof
        Summary:      Get Allof
        Description:  None
        """

        method = "get"

        path = "/allof"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/allof"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/allof"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return AllOfResp.model_validate(response.json())

    async def get_discriminated_oneof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> DiscriminatedOneOfResp | None:
        """
        GET /discriminated-oneof
        Operation ID: get_discriminated_oneof
        Summary:      Get discriminated oneof
        Description:  None
        """

        method = "get"

        path = "/discriminated-oneof"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/discriminated-oneof"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/discriminated-oneof"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return DiscriminatedOneOfResp.model_validate(response.json())

    async def get_object_slow(
        self,
        path_params: GetObjectSlowPathParams | dict[str, Any],
        query_params: GetObjectSlowQueryParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> GetObjectResp | UnknownError:
        """
        GET /slow/objects/{object_id}
        Operation ID: get_object_slow
        Summary:      Get Object Slow
        Description:  None
        """

        method = "get"

        if isinstance(path_params, GetObjectSlowPathParams):
            path = "/slow/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/slow/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        if isinstance(query_params, GetObjectSlowQueryParams):
            params = query_params.model_dump(by_alias=True, exclude_none=True)
        else:
            params = query_params

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/slow/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/slow/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return GetObjectResp.model_validate(response.json())

        if response.status_code == 500:
            if response.content is None:
                content = None
            else:
                content = response.content[:500]

            if self.logs_integration:
                self.logs_integration.log_error(req, resp)

            return UnknownError.model_validate(response.json())

    async def response_body_list_of_anyof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> ListAnyOfResp | None:
        """
        GET /nested-any-of
        Operation ID: response_body_list_of_anyof
        Summary:      Post Object With Request Body AnyOf
        Description:  None
        """

        method = "get"

        path = "/nested-any-of"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/nested-any-of"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/nested-any-of"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return ListAnyOfResp.model_validate(response.json())

    async def post_object_without_body(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PostObjectResp | None:
        """
        POST /post-without-body
        Operation ID: post_object_without_body
        Summary:      Post Object Without Body
        Description:  None
        """

        method = "post"

        path = "/post-without-body"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/post-without-body"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/post-without-body"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_object(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: PostObjectData | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PostObjectResp | None:
        """
        POST /objects
        Operation ID: post_object
        Summary:      Post Object
        Description:  None
        """

        method = "post"

        path = "/objects"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = await self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_form_object(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: PostObjectData | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PostObjectResp | None:
        """
        POST /objects-form-data
        Operation ID: post_form_object
        Summary:      Post Form Object
        Description:  None
        """

        method = "post"

        path = "/objects-form-data"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        headers_.update({"Content-Type": "application/x-www-form-urlencoded"})
        try:
            response = await self.client.request(
                method, url, data=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects-form-data"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects-form-data"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def post_multipart_form_data(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        files: Mapping[str, FileTypes] | Sequence[tuple[str, FileTypes]] | None = None,
        body: PostFile | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PostObjectResp | None:
        """
        POST /multipart-form-data
        Operation ID: post_multipart_form_data
        Summary:      Post Multipart Form Data
        Description:  None
        """

        method = "post"

        path = "/multipart-form-data"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PostFile):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        # Content-Type=multipart/form-data doesn't work, because header MUST contain boundaries
        # let library do it for us
        headers_.pop("Content-Type", None)

        try:
            response = await self.client.request(
                method, url, data=json, headers=headers_, params=params, content=content, auth=auth_, files=files
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/multipart-form-data"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/multipart-form-data"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def request_body_anyof(
        self,
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: RequestBodyAnyofRequestBody | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PostObjectResp | None:
        """
        POST /request-body-anyof
        Operation ID: request_body_anyof
        Summary:      Post Object With Request Body AnyOf
        Description:  None
        """

        method = "post"

        path = "/request-body-anyof"

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, RequestBodyAnyofRequestBody):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = await self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/request-body-anyof"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/request-body-anyof"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PostObjectResp.model_validate(response.json())

    async def patch_object(
        self,
        path_params: PatchObjectPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: PatchObjectData | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PatchObjectResp | None:
        """
        PATCH /objects/{object_id}
        Operation ID: patch_object
        Summary:      Patch Object
        Description:  None
        """

        method = "patch"

        if isinstance(path_params, PatchObjectPathParams):
            path = "/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PatchObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = await self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PatchObjectResp.model_validate(response.json())

    async def put_object(
        self,
        path_params: PutObjectPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: PutObjectData | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PutObjectResp | None:
        """
        PUT /objects/{object_id}
        Operation ID: put_object
        Summary:      Put Object
        Description:  None
        """

        method = "put"

        if isinstance(path_params, PutObjectPathParams):
            path = "/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = await self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PutObjectResp.model_validate(response.json())

    async def put_object_slow(
        self,
        path_params: PutObjectSlowPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        body: PutObjectData | dict[str, Any] | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> PutObjectResp | None:
        """
        PUT /slow/objects/{object_id}
        Operation ID: put_object_slow
        Summary:      Put Object Slow
        Description:  None
        """

        method = "put"

        if isinstance(path_params, PutObjectSlowPathParams):
            path = "/slow/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/slow/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        if isinstance(body, dict):
            json = body
        elif isinstance(body, PutObjectData):
            json = body.model_dump(by_alias=True)
        else:
            json = None

        try:
            response = await self.client.request(
                method, url, json=json, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/slow/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/slow/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return PutObjectResp.model_validate(response.json())

    async def delete_object(
        self,
        path_params: DeleteObjectPathParams | dict[str, Any],
        auth: BasicAuth | None = None,
        content: str | bytes | None = None,
        meta: PythogenMetaBox | None = None,
    ) -> DeleteObjectResp | None:
        """
        DELETE /objects/{object_id}
        Operation ID: delete_object
        Summary:      Delete Object
        Description:  None
        """

        method = "delete"

        if isinstance(path_params, DeleteObjectPathParams):
            path = "/objects/{object_id}".format(**path_params.model_dump(by_alias=True))
        else:
            path = "/objects/{object_id}".format(**path_params)

        url = f"{self.base_url}{path}"

        params = None

        headers_ = self.headers.copy()

        if auth is None:
            auth_ = DEFAULT_AUTH
        elif isinstance(auth, httpx.Auth):
            auth_ = auth
        else:
            auth_ = (auth.username, auth.password)

        try:
            response = await self.client.request(
                method, url, headers=headers_, params=params, content=content, auth=auth_
            )
        except Exception as exc:
            if self.metrics_integration:
                if self.metrics_integration.shadow_path():
                    metrics_path = "/objects/:object_id"
                else:
                    metrics_path = path
                self.metrics_integration.on_request_error(self.client_name, exc, method, metrics_path)

            raise exc

        if self.metrics_integration:
            if self.metrics_integration.shadow_path():
                metrics_path = "/objects/:object_id"
            else:
                metrics_path = path
            self.metrics_integration.on_request_success(self.client_name, response, method, metrics_path)

        req = RequestBox(
            client_name=self.client_name,
            method=method,
            url=url,
            params=params,
            headers=headers_,
            content=content,
        )

        resp = ResponseBox(
            status_code=response.status_code,
        )

        if meta:
            meta.request = req
            meta.response = resp

        if response.status_code == 200:
            return DeleteObjectResp.model_validate(response.json())

    async def close(self) -> None:
        await self.client.aclose()

    def _get_url(self, path: str) -> str:
        return f"{self.base_url}{path}"

    def log_extra(self, **kwargs: Any) -> dict[str, Any]:
        return {"extra": {"props": {"data": kwargs}}}

    def log_error(self, client_name: str, method, url: str, params, content, headers) -> None:
        msg = "request error"
        msg += f" | client={client_name}"
        msg += f" | method={method}"
        msg += f" | url={url}"
        msg += f" | params={params}"
        msg += f" | content={content}"
        msg += f" | headers={headers}"

        logging.error(
            msg,
            **self.log_extra(
                client=client_name,
                method=method,
                content=content,
                url=url,
                params=params,
            ),
        )

    def _parse_any_of(self, item: dict[str, Any], schema_classes: list[Any]) -> Any:
        for schema_class in schema_classes:
            try:
                return schema_class.model_validate(item)
            except:
                continue

        raise Exception('Can\'t parse "{item}"')


RequestBodyAnyofRequestBody.model_rebuild()
GetListObjectsResponse200.model_rebuild()
RewardsListItem.model_rebuild()
GetObjectWithInlineArrayResponse200.model_rebuild()
GetObjectWithArrayResponseResponse200.model_rebuild()
GetObjectWithArrayResponseResponse200Item.model_rebuild()
GetObjectNoRefSchemaResponse200.model_rebuild()
IntEnumOrNullObj.model_rebuild()
OptionalAnyofStringDataObj.model_rebuild()
AnimalObj.model_rebuild()
AnyOfChildObj.model_rebuild()
TierObj.model_rebuild()
AllOfRefObjItem2.model_rebuild()
Cat.model_rebuild()
Data.model_rebuild()
AllOfRefObj.model_rebuild()
AnyOfChildItem.model_rebuild()
ListAnyOfResp.model_rebuild()
SafetyKeyForTesting.model_rebuild()
UnknownError.model_rebuild()
DeleteObjectResp.model_rebuild()
PutObjectResp.model_rebuild()
PatchObjectResp.model_rebuild()
PostObjectResp.model_rebuild()
PostFile.model_rebuild()
PutObjectData.model_rebuild()
PatchObjectData.model_rebuild()
PostObjectData.model_rebuild()
GetObjectResp.model_rebuild()
GetMessageResp.model_rebuild()
Dog.model_rebuild()
DogWithKind.model_rebuild()
CatWithKind.model_rebuild()
DiscriminatedOneOfResp.model_rebuild()
AllOfResp.model_rebuild()
